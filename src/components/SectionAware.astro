---
import { Image } from "astro:assets";

export interface Props {
  sources: Array<{
    srcset: string;
    media?: string;
    type?: string;
  }>;
  src: string;
  alt: string;
  width?: string;
  height?: string;
  class?: string;
  placeholder?: string;
  sectionSelector?: string; // Селектор для определения секций
  preloadSections?: number; // Количество секций для предзагрузки (по умолчанию 1)
}

const {
  sources,
  src,
  alt,
  width,
  height,
  class: className = "",
  placeholder = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 300"%3E%3Crect fill="%23e0e0e0"/%3E%3C/svg%3E',
  sectionSelector = "section, .section, [data-section]",
  preloadSections = 1,
} = Astro.props;

const pictureId = `section-lazy-${Math.random().toString(36).substr(2, 9)}`;
---

<picture
  class={`section-lazy-picture ${className}`}
  data-picture-id={pictureId}
  data-section-selector={sectionSelector}
  data-preload-sections={preloadSections}
>
  {
    sources.map((source) => (
      <source
        data-srcset={source.srcset}
        media={source.media}
        type={source.type}
      />
    ))
  }
  <img
    data-src={src}
    src={placeholder}
    alt={alt}
    width={width}
    height={height}
    class="section-lazy-img"
  />
</picture>

<script>
  interface SectionInfo {
    element: Element;
    index: number;
    pictures: Element[];
  }

  class SectionAwareLazyLoader {
    private pictures: NodeListOf<Element>;
    private loadedPictures: Set<Element> = new Set();
    private loadingPictures: Set<Element> = new Set();
    private sections: Map<Element, SectionInfo> = new Map();
    private currentVisibleSection: Element | null = null;
    private sectionObserver: IntersectionObserver | null = null;

    constructor() {
      this.pictures = document.querySelectorAll(".section-lazy-picture");
      if (this.pictures.length > 0) {
        this.init();
      }
    }

    private init() {
      if ("IntersectionObserver" in window) {
        this.mapPicturesToSections();
        this.setupSectionObserver();
        this.setupFallbackObserver();
      } else {
        this.loadAllPictures();
      }
    }

    private mapPicturesToSections() {
      // Получаем селектор секций из первой картинки (предполагаем одинаковый для всех)
      const sectionSelector =
        this.pictures[0].getAttribute("data-section-selector") || "section";
      const allSections = Array.from(
        document.querySelectorAll(sectionSelector)
      );

      // Создаём карту секций с их индексами и картинками
      allSections.forEach((section, index) => {
        const sectionPictures: Element[] = [];

        // Находим все картинки, которые находятся внутри этой секции
        this.pictures.forEach((picture) => {
          if (section.contains(picture)) {
            sectionPictures.push(picture);
          }
        });

        this.sections.set(section, {
          element: section,
          index: index,
          pictures: sectionPictures,
        });
      });

      // Отладочная информация
    }

    private setupSectionObserver() {
      // Observer для отслеживания текущей видимой секции
      this.sectionObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting && entry.intersectionRatio > 0.3) {
              // Обновляем текущую видимую секцию
              this.currentVisibleSection = entry.target;
              this.handleSectionChange(entry.target);
            }
          });
        },
        {
          rootMargin: "0px",
          threshold: [0.3, 0.5, 0.7], // Несколько порогов для более точного определения
        }
      );

      // Наблюдаем за всеми секциями

      this.sections.forEach((info, section) => {
        this.sectionObserver?.observe(section);
      });
    }

    private handleSectionChange(visibleSection: Element) {
      const currentSectionInfo = this.sections.get(visibleSection);
      if (!currentSectionInfo) return;

      // Проходим по всем секциям и проверяем, какие картинки нужно загрузить
      this.sections.forEach((sectionInfo, section) => {
        // Для каждой картинки в секции проверяем, нужно ли её загружать
        sectionInfo.pictures.forEach((picture) => {
          const preloadCount = parseInt(
            picture.getAttribute("data-preload-sections") || "1"
          );

          // Вычисляем, должна ли загружаться картинка
          // Картинка должна загружаться, если:
          // - Мы находимся в секции N
          // - Картинка находится в секции от N до N + preloadCount
          const shouldLoad =
            sectionInfo.index <= currentSectionInfo.index + preloadCount &&
            sectionInfo.index >= currentSectionInfo.index;

          if (
            shouldLoad &&
            !this.loadedPictures.has(picture) &&
            !this.loadingPictures.has(picture)
          ) {
            this.loadPicture(picture);
          }
        });
      });
    }

    private setupFallbackObserver() {
      // Дополнительный observer как запасной вариант для картинок вне секций
      const fallbackObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              const picture = entry.target;

              // Загружаем только если картинка ещё не загружена и не в процессе
              if (
                !this.loadedPictures.has(picture) &&
                !this.loadingPictures.has(picture)
              ) {
                this.loadPicture(picture);
              }
            }
          });
        },
        {
          rootMargin: "100px",
          threshold: 0,
        }
      );

      // Наблюдаем только за картинками, которые не находятся ни в одной секции
      this.pictures.forEach((picture) => {
        let isInSection = false;
        this.sections.forEach((sectionInfo) => {
          if (sectionInfo.pictures.includes(picture)) {
            isInSection = true;
          }
        });

        if (!isInSection) {
          fallbackObserver.observe(picture);
        }
      });
    }

    private loadPicture(picture: Element) {
      // Предотвращаем повторную загрузку
      if (
        this.loadedPictures.has(picture) ||
        this.loadingPictures.has(picture)
      ) {
        return;
      }

      this.loadingPictures.add(picture);
      picture.classList.add("is-loading");

      const img = picture.querySelector("img") as HTMLImageElement;
      const sources = picture.querySelectorAll("source");

      // Загружаем source элементы
      sources.forEach((source) => {
        const srcset = source.dataset.srcset;
        if (srcset) {
          source.srcset = srcset;
          source.removeAttribute("data-srcset");
        }
      });

      // Загружаем изображение
      const src = img.dataset.src;
      if (src) {
        const tempImg = new Image();

        tempImg.onload = () => {
          img.src = src;
          img.classList.add("loaded");
          img.removeAttribute("data-src");
          picture.classList.remove("is-loading");
          picture.classList.add("picture-loaded");

          this.loadingPictures.delete(picture);
          this.loadedPictures.add(picture);
        };

        tempImg.onerror = () => {
          img.classList.add("error");
          picture.classList.remove("is-loading");
          picture.classList.add("picture-error");

          this.loadingPictures.delete(picture);
        };

        // Определяем правильный источник на основе media queries
        const currentSource = this.getCurrentSource(picture);
        tempImg.src = currentSource || src;
      }
    }

    private getCurrentSource(picture: Element): string | null {
      const sources = picture.querySelectorAll("source");

      for (const source of sources) {
        const media = source.getAttribute("media");
        if (media && window.matchMedia(media).matches) {
          return (
            source.getAttribute("srcset") || source.getAttribute("data-srcset")
          );
        }
      }

      return null;
    }

    private loadAllPictures() {
      // Fallback: загружаем все картинки для браузеров без IntersectionObserver
      this.pictures.forEach((picture) => {
        this.loadPicture(picture);
      });
    }
  }

  // Инициализация при загрузке DOM
  document.addEventListener("DOMContentLoaded", () => {
    new SectionAwareLazyLoader();
  });

  // Добавляем визуальный индикатор для отладки (можно удалить в продакшене)
  if (import.meta.env.DEV) {
    document.addEventListener("DOMContentLoaded", () => {
      const debugStyle = document.createElement("style");
      debugStyle.textContent = `
        .section-lazy-picture[data-picture-id]::after {
          content: attr(data-picture-id);
          position: absolute;
          top: 10px;
          left: 10px;
          background: rgba(0, 0, 0, 0.7);
          color: white;
          padding: 4px 8px;
          font-size: 10px;
          border-radius: 4px;
          z-index: 10;
          pointer-events: none;
        }
        
        .section-lazy-picture.picture-loaded::after {
          background: rgba(0, 128, 0, 0.7);
        }
        
        .section-lazy-picture.is-loading::after {
          background: rgba(255, 165, 0, 0.7);
        }
      `;
      document.head.appendChild(debugStyle);
    });
  }
</script>

<style>
  .section-lazy-picture {
    background: linear-gradient(135deg, #f0f0f0 0%, #e5e5e5 100%);
  }

  /* Индикатор загрузки */
  .section-lazy-picture.is-loading::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background:
      linear-gradient(
        90deg,
        transparent,
        rgba(255, 255, 255, 0.5),
        transparent
      ),
      linear-gradient(135deg, #f0f0f0 0%, #e5e5e5 100%);
    background-size:
      200% 100%,
      100% 100%;
    animation: loading 1.5s linear infinite;
    z-index: 1;
  }

  @keyframes loading {
    0% {
      background-position:
        -200% center,
        center;
    }
    100% {
      background-position:
        200% center,
        center;
    }
  }

  .section-lazy-img {
    width: 100%;
    object-fit: cover;
    opacity: 0;

    transition: opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .section-lazy-img.loaded {
    opacity: 1;
  }

  /* Плавное появление */
  .section-lazy-picture.picture-loaded {
    background: transparent;
    animation: reveal 0.8s ease-out;
  }

  @keyframes reveal {
    from {
      transform: translateY(10px);
      opacity: 0.8;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }

  /* Состояние ошибки */
  .section-lazy-picture.picture-error {
    background: linear-gradient(135deg, #ffe0e0 0%, #ffc0c0 100%);
    min-height: 200px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .section-lazy-picture.picture-error::after {
    content: "❌ Изображение не загружено";
    color: #d32f2f;
    font-size: 14px;
    padding: 10px;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 4px;
  }
</style>
